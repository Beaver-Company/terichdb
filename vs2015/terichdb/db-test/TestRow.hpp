#pragma once

//*******************************************************************
// WARNING: DO NOT modify this file!
// This file is generated by terichdb-schema-compile.exe
// with dbmeta file: "dbmeta.json"
//
// Keep "/path/to/your/database/dbmeta.json" being consitent with
// this dbmeta file: "dbmeta.json"
//*******************************************************************

#include <terark/terichdb/db_table.hpp>
#include <terark/io/DataIO.hpp>
#include <terark/io/MemStream.hpp>
#include <terark/io/RangeStream.hpp>
#include <boost/static_assert.hpp>


namespace DbTest {

  struct TestRow {
    std::uint64_t id;
    terark::terichdb::Schema::Fixed<19> fix;
    terark::terichdb::Schema::Fixed<19> fix2;
    std::string str0;
    std::string str1;
    std::string str2;
    std::string str3;
    std::string str4;

    DATA_IO_LOAD_SAVE(TestRow,
      &id
      &fix
      &fix2
      &terark::terichdb::Schema::StrZero(str0)
      &terark::terichdb::Schema::StrZero(str1)
      &str2
      &str3
      &terark::RestAll(str4)
    )

    TestRow& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }

    // DbTablePtr use none-const ref is just for ensure application code:
    // var 'tab' must be a 'DbTablePtr', can not be a 'DbTable*'
    static bool
    checkTableSchema(terark::terichdb::DbTablePtr& tab, bool checkColname = false);

    static terark::terichdb::DbTablePtr
    openTable(const boost::filesystem::path& dbdir, bool checkColname = false) {
      using namespace terark::terichdb;
      DbTablePtr tab = DbTable::open(dbdir);
      if (!checkTableSchema(tab, checkColname)) {
        THROW_STD(invalid_argument,
          "database schema is inconsistence with compiled c++ code, dbdir: %s",
          dbdir.string().c_str());
      }
      return tab;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 8) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "id") {
          return false;
        }
        if (colmeta.type != ColumnType::Uint64) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(1);
        const ColumnMeta& colmeta = schema.getColumnMeta(1);
        if (checkColname && colname != "fix") {
          return false;
        }
        if (colmeta.type != ColumnType::Fixed) {
          return false;
        }
        if (colmeta.fixedLen != 19) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(2);
        const ColumnMeta& colmeta = schema.getColumnMeta(2);
        if (checkColname && colname != "fix2") {
          return false;
        }
        if (colmeta.type != ColumnType::Fixed) {
          return false;
        }
        if (colmeta.fixedLen != 19) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(3);
        const ColumnMeta& colmeta = schema.getColumnMeta(3);
        if (checkColname && colname != "str0") {
          return false;
        }
        if (colmeta.type != ColumnType::StrZero) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(4);
        const ColumnMeta& colmeta = schema.getColumnMeta(4);
        if (checkColname && colname != "str1") {
          return false;
        }
        if (colmeta.type != ColumnType::StrZero) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(5);
        const ColumnMeta& colmeta = schema.getColumnMeta(5);
        if (checkColname && colname != "str2") {
          return false;
        }
        if (colmeta.type != ColumnType::Binary) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(6);
        const ColumnMeta& colmeta = schema.getColumnMeta(6);
        if (checkColname && colname != "str3") {
          return false;
        }
        if (colmeta.type != ColumnType::Binary) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(7);
        const ColumnMeta& colmeta = schema.getColumnMeta(7);
        if (checkColname && colname != "str4") {
          return false;
        }
        if (colmeta.type != ColumnType::Binary) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow

  struct TestRow_Colgroup_id {
    std::uint64_t id;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_id,
      &id
    )

    TestRow_Colgroup_id& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_id& select(const TestRow& ___row) {
      id = ___row.id;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.id = id;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 1) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "id") {
          return false;
        }
        if (colmeta.type != ColumnType::Uint64) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_id
  typedef TestRow_Colgroup_id TestRow_Index_id;


  struct TestRow_Colgroup_str0 {
    std::string str0;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_str0,
      &terark::RestAll(str0)
    )

    TestRow_Colgroup_str0& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_str0& select(const TestRow& ___row) {
      str0 = ___row.str0;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.str0 = str0;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 1) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "str0") {
          return false;
        }
        if (colmeta.type != ColumnType::StrZero) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_str0
  typedef TestRow_Colgroup_str0 TestRow_Index_str0;


  struct TestRow_Colgroup_str1 {
    std::string str1;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_str1,
      &terark::RestAll(str1)
    )

    TestRow_Colgroup_str1& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_str1& select(const TestRow& ___row) {
      str1 = ___row.str1;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.str1 = str1;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 1) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "str1") {
          return false;
        }
        if (colmeta.type != ColumnType::StrZero) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_str1
  typedef TestRow_Colgroup_str1 TestRow_Index_str1;


  struct TestRow_Colgroup_str2 {
    std::string str2;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_str2,
      &terark::RestAll(str2)
    )

    TestRow_Colgroup_str2& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_str2& select(const TestRow& ___row) {
      str2 = ___row.str2;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.str2 = str2;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 1) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "str2") {
          return false;
        }
        if (colmeta.type != ColumnType::Binary) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_str2
  typedef TestRow_Colgroup_str2 TestRow_Index_str2;


  struct TestRow_Colgroup_fix {
    terark::terichdb::Schema::Fixed<19> fix;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_fix,
      &fix
    )

    TestRow_Colgroup_fix& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_fix& select(const TestRow& ___row) {
      fix = ___row.fix;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.fix = fix;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 1) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "fix") {
          return false;
        }
        if (colmeta.type != ColumnType::Fixed) {
          return false;
        }
        if (colmeta.fixedLen != 19) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_fix
  typedef TestRow_Colgroup_fix TestRow_Index_fix;


  struct TestRow_Colgroup_str0_str1 {
    std::string str0;
    std::string str1;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_str0_str1,
      &terark::terichdb::Schema::StrZero(str0)
      &terark::RestAll(str1)
    )

    TestRow_Colgroup_str0_str1& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_str0_str1& select(const TestRow& ___row) {
      str0 = ___row.str0;
      str1 = ___row.str1;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.str0 = str0;
      ___row.str1 = str1;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 2) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "str0") {
          return false;
        }
        if (colmeta.type != ColumnType::StrZero) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(1);
        const ColumnMeta& colmeta = schema.getColumnMeta(1);
        if (checkColname && colname != "str1") {
          return false;
        }
        if (colmeta.type != ColumnType::StrZero) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_str0_str1
  typedef TestRow_Colgroup_str0_str1 TestRow_Index_str0_str1;


  struct TestRow_Colgroup_fix2 {
    terark::terichdb::Schema::Fixed<19> fix2;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_fix2,
      &fix2
    )

    TestRow_Colgroup_fix2& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_fix2& select(const TestRow& ___row) {
      fix2 = ___row.fix2;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.fix2 = fix2;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 1) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "fix2") {
          return false;
        }
        if (colmeta.type != ColumnType::Fixed) {
          return false;
        }
        if (colmeta.fixedLen != 19) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_fix2

  struct TestRow_Colgroup_str34 {
    std::string str3;
    std::string str4;

    DATA_IO_LOAD_SAVE(TestRow_Colgroup_str34,
      &str3
      &terark::RestAll(str4)
    )

    TestRow_Colgroup_str34& decode(terark::fstring ___row) {
      terark::NativeDataInput<terark::MemIO> ___dio(___row.range());
      ___dio >> *this;
      return *this;
    }
    terark::fstring
    encode(terark::NativeDataOutput<terark::AutoGrownMemIO>& ___dio) const {
      ___dio.rewind();
      ___dio << *this;
      return ___dio.written();
    }
    TestRow_Colgroup_str34& select(const TestRow& ___row) {
      str3 = ___row.str3;
      str4 = ___row.str4;
      return *this;
    }
    void assign_to(TestRow& ___row) const {
      ___row.str3 = str3;
      ___row.str4 = str4;
    }

    static bool
    checkSchema(const terark::terichdb::Schema& schema, bool checkColname = false) {
      using namespace terark;
      using namespace terark::terichdb;
      if (schema.columnNum() != 2) {
        return false;
      }
      {
        const fstring     colname = schema.getColumnName(0);
        const ColumnMeta& colmeta = schema.getColumnMeta(0);
        if (checkColname && colname != "str3") {
          return false;
        }
        if (colmeta.type != ColumnType::Binary) {
          return false;
        }
      }
      {
        const fstring     colname = schema.getColumnName(1);
        const ColumnMeta& colmeta = schema.getColumnMeta(1);
        if (checkColname && colname != "str4") {
          return false;
        }
        if (colmeta.type != ColumnType::Binary) {
          return false;
        }
      }
      return true;
    }
  }; // TestRow_Colgroup_str34

  // DbTablePtr use none-const ref is just for ensure application code:
  // var 'tab' must be a 'DbTablePtr', can not be a 'DbTable*'
  inline bool
  TestRow::checkTableSchema(terark::terichdb::DbTablePtr& tab, bool checkColname) {
    using namespace terark::terichdb;
    assert(tab.get() != nullptr);
    const SchemaConfig& sconf = tab->getSchemaConfig();
    if (!TestRow::checkSchema(*sconf.m_rowSchema)) {
      return false;
    }
    if (!TestRow_Colgroup_id::checkSchema(
          sconf.getColgroupSchema(0), checkColname)) {
      return false;
    }
    if (!TestRow_Colgroup_str0::checkSchema(
          sconf.getColgroupSchema(1), checkColname)) {
      return false;
    }
    if (!TestRow_Colgroup_str1::checkSchema(
          sconf.getColgroupSchema(2), checkColname)) {
      return false;
    }
    if (!TestRow_Colgroup_str2::checkSchema(
          sconf.getColgroupSchema(3), checkColname)) {
      return false;
    }
    if (!TestRow_Colgroup_fix::checkSchema(
          sconf.getColgroupSchema(4), checkColname)) {
      return false;
    }
    if (!TestRow_Colgroup_str0_str1::checkSchema(
          sconf.getColgroupSchema(5), checkColname)) {
      return false;
    }
    if (!TestRow_Colgroup_fix2::checkSchema(
          sconf.getColgroupSchema(6), checkColname)) {
      return false;
    }
    if (!TestRow_Colgroup_str34::checkSchema(
          sconf.getColgroupSchema(7), checkColname)) {
      return false;
    }
    return true;
  } // TestRow

} // namespace DbTest
